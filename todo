Signal Ideas
game.signal(:mode) # tuple signal
game.signal(:current_round) # singleton relation signal

game.current_round.signal(:mode) # tuple signal
game.signal(:current_round).signal(:mode) # derived tuple signal
game.signal(:current_round).signal(:mode) # derived tuple signal


game.signal(:current_round).signal do |round|
  round.mode
end

domain = set of named relations
tuple = a set of named attributes + a set of named relations
topic = a set of named relations plus a representation


class Game < PT:Base
  topic do
    {
      :games => active_games,
      :
    }
  end
end

class GameTopic < Topic
  expose :games, :fruits, :veggies

  relates_to_many :games
  relates_to_many :active_games do
    games.where active
  end

  expose :answers

  :answers_without_correct
  :answers_with_correct

  def answers
    choice
  end


  def representation
  end
end

GameTopic.new(game).to_hash
GameTopic.new(game).to_json

game_topic.topic.to_json

relation1


game.exposed_domain = game.project(
  :games => active_games,
  :groups => active_games.join...

)

game.signal(:game_sessions) do |game_sessions| # relation signal
end

class DerivedSignal




  def initialize(operand, attribute)
    @operand = operand

    operand.on_change do |old_value, new_value|
      operand_signal.destroy
      @operand_signal = new_value.signal(attribute)
      operand_signal.on_change do
        operand_signal.value
#        trigger_on_change(old_value, new_value)
      end
      unless old_value.send(attribute) == new_value.send(attribute)
        trigger_on_change(old_value.send(attribute), new_value.send(attribute))
      end
    end




  end



end